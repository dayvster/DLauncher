#include "theme.h"
#include <QFile>
#include <QTextStream>
#include <QDir>
#include <QApplication>
#include <QWidget>
#include <QPalette>
#include <QFile>

ThemeManager::ThemeManager()
{
  setDefaults();
  loadTheme(defaultConfigPath());
  // Ensure builtin QSS files exist so users can tweak them if desired
  ensureBuiltinQssFiles();
}

void ThemeManager::setDefaults()
{
  theme.backgroundColor = QColor(30, 30, 30, 220);
  theme.borderColor = QColor(51, 51, 51, 255);
  theme.textColor = QColor(255, 255, 255, 255);
  theme.highlightColor = QColor(0, 188, 212, 100);
  theme.inputBackground = QColor(34, 34, 34, 255);
  theme.inputBorder = QColor(68, 68, 68, 255);
  theme.font = QFont("FiraCode", 16);
  theme.fontSize = 16;
  theme.borderRadius = 10;
  theme.padding = 10;
  theme.selectionColor = QColor(0, 188, 212, 80);
  theme.rowBackground = QColor(255, 255, 255, 10);
  theme.rowHover = QColor(155, 255, 255, 30);
  theme.windowWidth = 500;
  theme.windowHeight = 300;
  theme.windowPosX = -1;
  theme.windowPosY = -1;
}

bool ThemeManager::loadTheme(const QString &path)
{
  QFile file(path);
  if (!file.exists())
    return false;
  if (!file.open(QIODevice::ReadOnly | QIODevice::Text))
    return false;
  QTextStream in(&file);
  bool anySet = false;
  using Setter = std::function<void(const QString &)>;
  QMap<QString, Setter> setters = {
      {"background", [&](const QString &v)
       { theme.backgroundColor = QColor(v); anySet = true; }},
      {"border", [&](const QString &v)
       { theme.borderColor = QColor(v); anySet = true; }},
      {"text", [&](const QString &v)
       { theme.textColor = QColor(v); anySet = true; }},
      {"highlight", [&](const QString &v)
       { theme.highlightColor = QColor(v); anySet = true; }},
      {"input_bg", [&](const QString &v)
       { theme.inputBackground = QColor(v); anySet = true; }},
      {"input_border", [&](const QString &v)
       { theme.inputBorder = QColor(v); anySet = true; }},
      {"font", [&](const QString &v)
       { theme.font = QFont(v, theme.fontSize); anySet = true; }},
      {"font_size", [&](const QString &v)
       { theme.fontSize = v.toInt(); theme.font.setPointSize(theme.fontSize); anySet = true; }},
      {"border_radius", [&](const QString &v)
       { theme.borderRadius = v.toInt(); anySet = true; }},
      {"padding", [&](const QString &v)
       { theme.padding = v.toInt(); anySet = true; }},
      {"window_width", [&](const QString &v)
       { theme.windowWidth = v.toInt(); anySet = true; }},
      {"window_height", [&](const QString &v)
       { theme.windowHeight = v.toInt(); anySet = true; }},
      {"window_pos_x", [&](const QString &v)
       { theme.windowPosX = v.toInt(); anySet = true; }},
      {"window_pos_y", [&](const QString &v)
       { theme.windowPosY = v.toInt(); anySet = true; }},
      {"selection", [&](const QString &v)
       { theme.selectionColor = QColor(v); anySet = true; }},
      {"row_bg", [&](const QString &v)
       { theme.rowBackground = QColor(v); anySet = true; }},
      {"row_hover", [&](const QString &v)
       { theme.rowHover = QColor(v); anySet = true; }}};
  while (!in.atEnd())
  {
    QString line = in.readLine().trimmed();
    if (line.isEmpty() || line.startsWith('#'))
      continue;
    auto parts = line.split('=');
    if (parts.size() != 2)
      continue;
    QString key = parts[0].trimmed();
    QString value = parts[1].trimmed();
    if (setters.contains(key))
      setters[key](value);
  }
  if (!anySet)
    setDefaults();
  return true;
}

bool ThemeManager::loadStyleSheet(const QString &path)
{
  QFile f(path);
  if (!f.exists()) return false;
  if (!f.open(QIODevice::ReadOnly | QIODevice::Text)) return false;
  QTextStream in(&f);
  QString contents = in.readAll();
  // store stylesheet in a simple file under ~/.config/dlauncher/style.qss
  try {
    QString outPath = ThemeManager::defaultStylePath();
    QFile out(outPath);
    QFile::remove(outPath);
    if (out.open(QIODevice::WriteOnly | QIODevice::Text)) {
      QTextStream o(&out);
      o << contents;
      out.close();
    }
  } catch(...) {}
  return true;
}

QString ThemeManager::defaultThemesDir()
{
  return QDir::homePath() + "/.config/dlauncher/themes";
}

void ThemeManager::ensureBuiltinQssFiles()
{
  QDir d(defaultThemesDir());
  if (!d.exists()) d.mkpath(".");
  // For each builtin, write its generated QSS if the file doesn't already exist
  // Instead of generating QSS here, copy packaged theme files from the
  // repository 'themes' directory (if present in the working tree) so that
  // designers can ship curated QSS files rather than autogenerated ones.
  QString repoThemesPath = QDir::current().filePath("themes");
  QDir repoThemesDir(repoThemesPath);
  if (repoThemesDir.exists()) {
    for (const QString &fileName : repoThemesDir.entryList(QStringList() << "*.qss", QDir::Files)) {
      QString src = repoThemesDir.filePath(fileName);
      QString dst = d.filePath(fileName);
      if (QFile::exists(dst)) continue; // don't overwrite
      QFile::copy(src, dst);
    }
  } else {
    // Fallback: generate QSS from Theme structs
    for (const QString &name : ThemeManager::builtinNames()) {
      QString fname = d.filePath(name + ".qss");
      QFile f(fname);
      if (f.exists()) continue; // don't overwrite
      Theme t = ThemeManager::themeForBuiltin(name);
      QString qss = ThemeManager::qssForTheme(t);
      if (f.open(QIODevice::WriteOnly | QIODevice::Text)) {
        QTextStream out(&f);
        out << qss;
        f.close();
      }
    }
  }
}

QString ThemeManager::styleSheet() const
{
  QString path = ThemeManager::defaultStylePath();
  QFile f(path);
  if (!f.exists()) return "";
  if (!f.open(QIODevice::ReadOnly | QIODevice::Text)) return "";
  QTextStream in(&f);
  return in.readAll();
}

const Theme &ThemeManager::currentTheme() const
{
  return theme;
}

QString ThemeManager::defaultConfigPath()
{
  return QDir::homePath() + "/.config/dlauncher/theme";
}

QString ThemeManager::defaultStylePath()
{
  return QDir::homePath() + "/.config/dlauncher/style.qss";
}

QString ThemeManager::loadQssFile(const QString &path)
{
  QFile f(path);
  if (!f.exists()) return QString();
  if (!f.open(QIODevice::ReadOnly | QIODevice::Text)) return QString();
  QTextStream in(&f);
  return in.readAll();
}

void ThemeManager::applyStyle(QApplication &app, QWidget *root, const QString &qss, const Theme &t)
{
  if (!qss.isEmpty()) {
    app.setStyleSheet(qss);
    if (root) root->setStyleSheet(qss);
  }
  // Apply palette and font derived from Theme
  QPalette pal = app.palette();
  pal.setColor(QPalette::Window, t.backgroundColor);
  pal.setColor(QPalette::WindowText, t.textColor);
  pal.setColor(QPalette::Button, t.rowBackground);
  pal.setColor(QPalette::ButtonText, t.textColor);
  pal.setColor(QPalette::Base, t.inputBackground);
  pal.setColor(QPalette::Text, t.textColor);
  pal.setColor(QPalette::Highlight, t.selectionColor);
  app.setPalette(pal);
  app.setFont(t.font);
  if (root) { root->setPalette(pal); root->setAutoFillBackground(true); }
}

QString ThemeManager::builtinStyle(const QString &name)
{
  // Prefer generating QSS from the Theme struct so it can target widget object
  // names and be consistent with the Theme values used elsewhere in code.
  Theme t = ThemeManager::themeForBuiltin(name);
  return ThemeManager::qssForTheme(t);
}

QString ThemeManager::qssForTheme(const Theme &t)
{
  auto rgba = [](const QColor &c){
    int r,g,b,a; c.getRgb(&r,&g,&b,&a);
    // use alpha as fractional value in CSS rgba()
    double af = a / 255.0;
    return QString("rgba(%1,%2,%3,%4)").arg(r).arg(g).arg(b).arg(QString::number(af,'f',2));
  };

  QString bg = rgba(t.backgroundColor);
  QString txt = rgba(t.textColor);
  QString row = rgba(t.rowBackground);
  QString rowHover = rgba(t.rowHover);
  QString inputBg = rgba(t.inputBackground);
  QString inputBorder = rgba(t.inputBorder);
  QString selection = rgba(t.selectionColor);

  // Generate a concise QSS that covers global fallbacks and targeted rules
  QString q = QString(R"(
/* global fallbacks */
QWidget { background: %1; color: %2; font-family: "%9"; }
QListWidget#AppListWidget, QListWidget { background: transparent; color: %2; border: none; }
QLineEdit { background: %6; color: %2; border: 2px solid %7; border-radius: %4px; padding: 6px; font-size: %10px; }
QPushButton { background: rgba(0,0,0,0); color: %2; border: 1px solid rgba(255,255,255,0.12); border-radius: 6px; padding: 4px; }
QScrollBar:vertical { background: transparent; width: 10px; }
QListWidget::item:selected { background: %8; color: %2; }

/* targeted rules for our app */
QWidget#MainWindow { background: %1; color: %2; }
QWidget#AppRow { background: %3; border-radius: %4px; padding: 6px; }
QWidget#AppRow QLabel { color: %2; font-size: %10px; }
/* pin/hide buttons removed */
 
 )")
    .arg(bg)
    .arg(txt)
    .arg(row)
    .arg(t.borderRadius)
    .arg(rowHover)
    .arg(inputBg)
    .arg(inputBorder)
    .arg(selection)
    .arg(t.font.family())
    .arg(t.font.pointSize());
  return q;
}

Theme ThemeManager::themeForBuiltin(const QString &name)
{
  Theme t;
  if (name == "light") {
    t.backgroundColor = QColor("#F7F7F7");
    t.textColor = QColor("#222222");
    t.inputBackground = QColor("#FFFFFF");
    t.inputBorder = QColor("#CCCCCC");
    t.rowBackground = QColor(255,255,255,180);
    t.rowHover = QColor(230,230,230,200);
    t.selectionColor = QColor("#BFD7FF");
    t.font = QFont("Sans", 14);
    return t;
  }
  if (name == "solarized") {
    t.backgroundColor = QColor("#002b36");
    t.textColor = QColor("#839496");
    t.inputBackground = QColor("#073642");
    t.inputBorder = QColor("#586e75");
    t.rowBackground = QColor(0,43,54,200);
    t.rowHover = QColor(7,54,66,200);
    t.selectionColor = QColor("#586e75");
    t.font = QFont("Sans", 14);
    return t;
  }
  if (name == "tokyo-night" || name == "tokyo") {
    // Tokyo Night (storm-like dark blue/purple palette)
    t.backgroundColor = QColor("#1a1b26");
    t.textColor = QColor("#c0caf5");
    t.inputBackground = QColor("#24283b");
    t.inputBorder = QColor("#394264");
    t.rowBackground = QColor(31,35,53,200); // slightly lighter than bg
    t.rowHover = QColor(42,46,66,220);
    t.selectionColor = QColor("#7aa2f7");
    t.font = QFont("FiraCode", 15);
    return t;
  }
  if (name == "catppuccin" || name == "catpp") {
    // Catppuccin (Mocha-like warm dark theme)
    t.backgroundColor = QColor("#1e1e2e");
    t.textColor = QColor("#cdd6f4");
    t.inputBackground = QColor("#11111b");
    t.inputBorder = QColor("#313244");
    t.rowBackground = QColor(49,50,68,220);
    t.rowHover = QColor(68,71,90,230);
    t.selectionColor = QColor("#89b4fa");
    t.font = QFont("FiraCode", 15);
    return t;
  }
  if (name == "dracula") {
    // Dracula theme
    t.backgroundColor = QColor("#282a36");
    t.textColor = QColor("#f8f8f2");
    t.inputBackground = QColor("#44475a");
    t.inputBorder = QColor("#6272a4");
    t.rowBackground = QColor(68,71,90,200);
    t.rowHover = QColor(98,114,164,220);
    t.selectionColor = QColor("#bd93f9");
    t.font = QFont("FiraCode", 15);
    return t;
  }
  if (name == "ayu") {
    // Ayu (dark) theme
    t.backgroundColor = QColor("#0F1419");
    t.textColor = QColor("#e6e1cf");
    t.inputBackground = QColor("#0b0f14");
    t.inputBorder = QColor("#2b2f33");
    t.rowBackground = QColor(20,24,30,200);
    t.rowHover = QColor(34,40,48,220);
    t.selectionColor = QColor("#f07178");
    t.font = QFont("FiraCode", 15);
    return t;
  }
  // default dark
  t.backgroundColor = QColor(30,30,30,220);
  t.textColor = QColor(255,255,255);
  t.inputBackground = QColor(34,34,34);
  t.inputBorder = QColor(68,68,68);
  t.rowBackground = QColor(255,255,255,10);
  t.rowHover = QColor(155,255,255,30);
  t.selectionColor = QColor(0,188,212,80);
  t.font = QFont("FiraCode", 16);
  return t;
}

QStringList ThemeManager::builtinNames()
{
  return QStringList() << "dark" << "light" << "solarized" << "tokyo-night" << "catppuccin" << "dracula" << "ayu";
}
